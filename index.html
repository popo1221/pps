<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<img src="v2.jpg">
			</section>
			<section>
				<h1>函数式编程入门</h1>
				<p>Functional Programming</p>
			</section>
			<section>
				<h2>主要内容</h2>
				<ol>
					<li class="fragment">什么是函数式编程</li>
					<li class="fragment">常见的几个概念</li>
					<li class="fragment">函数式编程的好处</li>
					<li class="fragment">函数式编程的JS库</li>
				</ol>
			</section>
			<section>
				<section>
					<h2>什么是函数式编程</h2>
				</section>
				<section>
					<p>三种编程范式</p>
					<ul>
						<li class="fragment">
							命令式编程(Imperative Programming)
							<p>
								专注于“如何去做”，关心解决问题的步骤。
							</p>
						</li>
						<li class="fragment">
							函数式编程(Functional Programming)
							<p>
								面向数据抽象，关心数据之间的映射关系。
							</p>
						</li>
						<li class="fragment">
							逻辑式编程(Logical Programming)
							<p>它设定答案须符合的规则来解决问题，而非设定步骤来解决问题。</p>
						</li>
					</ul>
				</section>
				<section>
					<p>
						在狭义上，函数式编程意味着没有可变变量、赋值、循环和其他命令式控制结构。即，纯函数式编程语言。
					</p>
					<ul>
						<li>Pure Lisp, XSLT, XPath, XQuery, FP</li>
						<li>Haskell(without I/O Monad or UnsafPerformIO)</li>
					</ul>
				</section>
				<section>
					<p>
						在广义上，函数式编程意味着专注于函数。
					</p>
					<ul>
						<li>Lisp, Scheme, Racket, Clojuer</li>
						<li>SML, Ocaml, F#</li>
						<li>Haskell</li>
						<li>Scala</li>
						<li>Smalltalk, Ruby</li>
					</ul>
				</section>

				<section>
					<h3>Lambda演算</h3>
					<p>用函数组合的方式来描述计算过程</p>
				</section>
				<section>
					<h3>Lambda演算的特点</h3>
					<ul>
						<li class="fragment">函数是第一等公民</li>
						<li class="fragment">数据是不可变的</li>
						<li class="fragment">强制使用纯函数</li>
						<li class="fragment">支持函数递归调用</li>
						<li class="fragment">函数只接受一个参数</li>
					</ul>
				</section>
				<section>
					<h2>什么是函数</h2>
					<p>
						函数式编程中的函数是指数学中的函数，即自变量的映射。（即一种东西和另一种东西之间的对应关系）。
					</p>
				</section>
				<section>
					<p>函数作为一等公民，可以用于任何地方。</p>
					<ul class="fragment">
						<li>可以用在函数内或函数外</li>
						<li>可以赋值给其他变量</li>
						<li>可以作为参数，传入另一个函数</li>
						<li>可以作为另一个函数的返回值</li>
					</ul>
				</section>
				<section>
					<p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。</p>
					<blockquote>
						所谓的副作用(Side Effect)，指的是函数内部与外部互动产生运算以外的其他结果。（比如，修改 全局变量）
					</blockquote>
				</section>
				<section>
					<p>纯函数满足以下条件：</p>
					<ul>
						<li>不依赖外部状态</li>
						<li>不改变外部状态</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h3>常见的几个概念</h3>
					<ul>
						<li>高阶函数</li>
						<li>函数的合成</li>
						<li>递归</li>
						<li>柯里化</li>
						<li>惰性链</li>
					</ul>
				</section>
				<section>
					<p>高阶函数</p>
					<p>以其他函数为参数的函数，或者返回其他函数的函数，我们称之为高阶函数</p>
					<pre>
							<code>
const compose = function(f, g) {
	return function(x) {
		return f(g(x));
	}
} 
							</code>
					</pre>
				</section>
				<section>
					<p>函数的合成</p>
					<p>如果一个函数需要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做“函数的合成”(compose)</p>
					<pre>
							<code>
const compose = function(f, g) {
	return function(x) {
		return f(g(x));
	}
} 
							</code>
					</pre>
				</section>
				<section>
						<p>函数的合成必须满足结合律</p>
						<img src="fgh.png">
						<pre>
								<code>compose(compose(h, g), f)
// 等价于
compose(h, compose(g, f))</code>
						</pre>
				</section>
				<section>
					<p>柯里化</p>
					<p>
						所谓柯里化，就是把一个多参数的函数，转化为单参数函数。
					</p>
					<pre>
								<code>
// 柯里化之前
function add(x, y) { 
	return x + y; 
}

add(1, 2) // 3

// 柯里化之后
function addX(y) {
	return function(x) {
		return add(x, y);
	}
}

const add2 = addX(2)
add2(1) // 3
								</code>
						</pre>
				</section>
				<section>
					<p>惰性求值是指在将表达式赋值给变量时并不计算表达式的值，而在变量第一次使用时才进行计算。</p>
					<pre>
								<code>

								</code>
						</pre>
				</section>
			</section>
			<section>
				<p>函数式编程的好处</p>
				<ul>
					<li>引用透明：函数的运行不依赖于外部变量或“状态”，只依赖于输入的参数</li>
					<li>没有副作用</li>
				</ul>
			</section>
			<section>
				<p>JavaScript</p>
				<ul>
					<li>underscore.js(lodash.js)</li>
					<li>RxJS</li>
					<li>Bilby</li>
				</ul>
			</section>
			<section>
				<p>参考</p>
				<ul>
					<li>
							<a href="https://blog.csdn.net/u013007900/article/details/79104110">函数式编程介绍</a>
					</li>
					<li>
							<a href="https://zhuanlan.zhihu.com/p/26174525">React世界的函数式编程</a>
					</li>
					<li>
							<a href="https://blog.csdn.net/u013007900/article/details/79104110">函数式编程介绍</a>
					</li>
					<li>
						<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">JS 函数式编程指南</a>
					</li>
					<li>
							<a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门教程</a>
						</li>
				</ul>
			</section>
		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
			]
		});
	</script>
</body>

</html>